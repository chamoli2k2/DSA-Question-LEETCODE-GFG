int mod = 1e9 + 7;
class Solution {
private:
    int solve(vector<pair<int,int>> &nums,vector<vector<vector<int>>> &dp,int idx,int Profit,int target,int k){
        // Base case
        // If no thieves left || idx is greater than bound
        if(k == 0 || idx >= nums.size()){
            return Profit >= target ? 1 : 0;
        }
        

        if(dp[idx][Profit][k] != -1) return dp[idx][Profit][k];

        // We have 2 choice either take or notake
        int take = 0;
        if(nums[idx].first <= k){
            take = solve(nums,dp,idx+1,Profit+nums[idx].second,target,k-nums[idx].first);
        }

        int notake = solve(nums,dp,idx+1,Profit,target,k);

        return dp[idx][Profit][k] = (take % mod + notake % mod) % mod;
    }
public:
    int profitableSchemes(int k, int minProfit, vector<int>& group, vector<int>& profit) {
        int n = group.size();
        int Sum = 0;
        vector<pair<int,int>> nums(n);
        for(int i=0;i<n;i++){
            nums[i] = {group[i],profit[i]};
            Sum += profit[i];
        }

        vector<vector<vector<int>>> dp(n,vector<vector<int>>(Sum+1,vector<int>(k+1,-1)));

        return solve(nums,dp,0,0,minProfit,k);
    }
};
